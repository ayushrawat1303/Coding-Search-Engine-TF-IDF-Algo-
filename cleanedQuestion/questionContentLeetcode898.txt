Dining Philosophers Five silent philosophers sit round table with bowls spaghetti Forks placed between each pair adjacent philosophers Each philosopher must alternately think eat However philosopher can only eat spaghetti when they have both left right forks Each fork can be held by only one philosopher so philosopher can use fork only if it not being used by another philosopher After individual philosopher finishes eating they need put down both forks so forks become available others philosopher can take fork on their right one on their left as they become available but cannot start eating before getting both forks Eating not limited by remaining amounts spaghetti stomach space infinite supply infinite demand assumed Design discipline behaviour concurrent algorithm such no philosopher will starve ie each can forever continue alternate between eating thinking assuming no philosopher can know when others may want eat think problem statement image above taken from wikipediaorg philosophers ids numbered from clockwise order Implement function void wantsToEatphilosopher pickLeftFork pickRightFork eat putLeftFork putRightFork where philosopher id philosopher who wants eat pickLeftFork pickRightFork functions you can call pick corresponding forks philosopher eat function you can call let philosopher eat once he has picked both forks putLeftFork putRightFork functions you can call put down corresponding forks philosopher philosophers assumed be thinking as long as they not asking eat function not being called with their number Five threads each representing philosopher will simultaneously use one object your class simulate process function may be called for same philosopher more than once even before last call ends Example Input Output Explanation number times each philosopher will call function output array describes calls you made functions controlling forks eat function its format output three integers id philosopher specifies fork left right specifies operation pick put eat Constraints