LFU Cache Design implement data structure for Least Frequently Used LFU cache Implement LFUCache class LFUCacheint capacity Initializes object with capacity data structure int getint key Gets value key if key exists cache Otherwise returns void putint key int value Update value key if present inserts key if not already present When cache reaches its capacity it should invalidate remove least frequently used key before inserting new item For this problem when there tie ie two more keys with same frequency least recently used key would be invalidated determine least frequently used key use counter maintained for each key cache key with smallest use counter least frequently used key When key first inserted into cache its use counter set due put operation use counter for key cache incremented either get put operation called on it functions get put must each run average time complexity Example Input Output Explanation cntx use counter for key cache will show last used order for tiebreakers leftmost element most recent LFUCache lfu new LFUCache lfuput cache cnt lfuput cache cnt cnt lfuget return cache cnt cnt lfuput LFU key because cnt smallest invalidate cache cnt cnt lfuget return not found lfuget return cache cnt cnt lfuput Both have same cnt but LRU invalidate cache cnt cnt lfuget return not found lfuget return cache cnt cnt lfuget return cache cnt cnt Constraints capacity key value most calls will be made get put